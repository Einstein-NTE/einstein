# -*- coding: cp1252 -*-
#==============================================================================
#
#	E I N S T E I N
#
#       Expert System for an Intelligent Supply of Thermal Energy in Industry
#       (www.iee-einstein.org)
#
#------------------------------------------------------------------------------
#
#	INTERFACES
#			
#------------------------------------------------------------------------------
#			
#	Definition of interfaces in between modules
#
#==============================================================================
#
#   EINSTEIN Version No.: 1.0
#   Created by: 	Hans Schweiger, Tom Sobota, Stoyan Danov
#                       10/03/2008 - 10/07/2008
#
#   Update No. 003
#
#   Since Version 1.0 revised by:
#                       Hans Schweiger          28/11/2008
#                       Hans Schweiger          08/04/2009
#                       Hans Schweiger          10/07/2009
#
#       Changes in last update:
#
#       28/11/2008: HS conversion to UNICODE; function setDefaultDemand eliminated
#       08/04/2009: HS  QWHEqTotal added
#       10/07/2009: HS  QWHWHEE added
#	
#------------------------------------------------------------------------------		
#	(C) copyleft energyXperts.BCN (E4-Experts SL), Barcelona, Spain 2008
#	www.energyxperts.net / info@energyxperts.net
#
#	This program is free software: you can redistribute it or modify it under
#	the terms of the GNU general public license as published by the Free
#	Software Foundation (www.gnu.org).
#
#==============================================================================

import MySQLdb
from einstein.GUI.status import Status
import einstein.GUI.pSQL as pSQL
import einstein.GUI.HelperClass as HelperClass
from einstein.modules.constants import *
from einstein.modules.messageLogger import *
import copy

QUERY = "Questionnaire_id = '%s' AND AlternativeProposalNo = '%s' ORDER BY IndexNo ASC"

class Interfaces(object):

#..........................................................................
# DATA BLOCK 1: energy flows in the system
    T = []      #temperature steps

# total heat demand and availability in the system

    QD_T = []       #aggregate heat demand as seen by the heat supply
    QA_T = []       #equipment. similar (identical ?) to USHm_T
    QD_Tt = []
    QA_Tt = []
    
# intermediate heat demand / availability within equipment cascade

    QD_T_mod = []    
    QA_T_mod = []
    QD_Tt_mod = []
    QA_Tt_mod = []

# UPH by processes
# Temperature dependent demand is calculated in createYearlyDemand

    UPH_T = []      #calculated in createYearlyDemand  
    UPHc_T = []
    UPHm_T = []
    UPHs_T = []
    UPHw_T = []
    UPH_Tt = []
    UPHw_Tt = []

    UPHTotal_T = []
    UPHTotal_Tt = []
    
    UPHwTotal_T = []
    UPHwTotal_Tt = []

    UPHProcTotal_Tt = []    # heat supplied externally to processes (= UPH - QHXProc)
    UPHProcTotal_T = []

    QWHAmb_Tt = []          # waste heat dissipated to ambient (not used)
    QWHAmb_T = []
    
# heat supplied by each equipment
    USHj_Tt = []    
    USHj_T = []
    USHj_t = []
    USHj = []
    
    USHTotal_Tt = []
    USHTotal_T = []
    
# waste heat absorbed (QHXj) and generated (QWHj) in each equipment
    QHXj_Tt = []    
    QHXj_T = []
    QHXj_t = []
    QHXj = []

    QHXProcTotal_Tt = []    # heat recovered and fed directly to processes
    QHXProcTotal_T = []

    QWHj_Tt = []    
    QWHj_T = []
    QWHj_t = []
    QWHj = []

# total waste heat generated by WHEEs

    QWHEE_Tt = []
    QWHEE_T = []
    
# other required outputs from system simulation (calculateEnergyFlows)

    FETFuel_j = []
    FETel_j = []
    ElGen_j = []
    FETHeat_j = []
    HPerYearEq = []
    
    QWHEqTotal_Tt = []    # heat recovered and fed directly to processes
    QWHEqTotal_T = []

# dictionary of the HC supply cascade. entries "equipeID" and "equipeNo"

    NEquipe = None
    cascadeSize = None
    cascadeUpdateLevel = -1 #indicates cascadeIndex (from 1 ... N) for which cascade is
                            #updated
                            #-1 indicates that not even demand of first cascade level is available
    cascade = []
    EquipTableDataList = []
    
#..........................................................................
# DATA BLOCK 2: graphics data dictionary for graphics on panels

    GData = {}

   
#------------------------------------------------------------------------------		
    def __init__(self):
#------------------------------------------------------------------------------		
#
# Instance initialization
#
        self.T = []
        for iT in range(Status.NT+1):
            self.T.append(iT*Status.TemperatureInterval)
        self.T.append(999.0)
        
#        self.setDefaultDemand()
        
#------------------------------------------------------------------------------		
#------------------------------------------------------------------------------		
    def createQ_Tt(self):
#------------------------------------------------------------------------------		
#   function for creating an empty matrix for temperature and time dependent
#   energy flows
#------------------------------------------------------------------------------		
        Q_Tt = []
        for iT in range(Status.NT+2):
            Q_Tt.append(self.createQ_t())

        return Q_Tt

#------------------------------------------------------------------------------		
    def createQ_t(self):
#------------------------------------------------------------------------------		
#   function for creating an empty vector for time dependent
#   energy flows
#------------------------------------------------------------------------------		
        Q_t = []
        for it in range(Status.Nt+1):
            Q_t.append(0.0)
        
        return Q_t

#------------------------------------------------------------------------------		
    def createQ_T(self):
#------------------------------------------------------------------------------		
#   function for creating an empty vector for time dependent
#   energy flows
#------------------------------------------------------------------------------		
        Q_T = []
        for iT in range(Status.NT+2):
            Q_T.append(0.0)
        
        return Q_T

#------------------------------------------------------------------------------		
    def calcQ_T(self,Q_Tt):
#------------------------------------------------------------------------------		
#   Function that calculates the annual integral
#------------------------------------------------------------------------------		

        Q_T = []
        for iT in range(Status.NT + 2):
            Q_T.append([])
            Q_T[iT] = 0
            for it in range(Status.Nt):
                Q_T[iT] += Q_Tt[iT][it]
            Q_T[iT] *= Status.EXTRAPOLATE_TO_YEAR
        return Q_T

#------------------------------------------------------------------------------		
    def initCascadeArrays(self,cascadeSize):
#------------------------------------------------------------------------------		
#..............................................................................
# initialising storage space for energy flows in cascade
# assigning total heat demand and availability to the first row in cascade

        logTrack("Interfaces (initCascadeArrays): creating cascade of size %s"%cascadeSize)
        if self.cascadeUpdateLevel < 0:
            logDebug("Interfaces (initCascadeArrays): demand profile not yet created")
            Status.processData.createAggregateDemand()

        self.QD_Tt_mod = []      
        self.QD_T_mod = []
        self.QA_Tt_mod = []       
        self.QA_T_mod = []

        self.QD_Tt_mod.append(self.createQ_Tt())       
        self.QD_T_mod.append(self.createQ_T())
        self.QA_Tt_mod.append(self.createQ_Tt())      
        self.QA_T_mod.append(self.createQ_T())

        for iT in range(Status.NT+2):
            for it in range(Status.Nt+1):
                self.QD_Tt_mod[0][iT][it] = self.QD_Tt[iT][it]
                self.QA_Tt_mod[0][iT][it] = self.QA_Tt[iT][it]
            self.QD_T_mod[0][iT] = self.QD_T[iT]
            self.QA_T_mod[0][iT] = self.QA_T[iT]

        logTrack("Interfaces (initCArrays): QD = %s"%self.QD_T_mod[0])
        self.cascadeSize = 0
        self.cascadeUpdateLevel = 0

        self.extendCascadeArrays(cascadeSize)
            
#------------------------------------------------------------------------------		
    def extendCascadeArrays(self,cascadeSize):
#------------------------------------------------------------------------------		
#..............................................................................
# creates storage space for energy flows in cascade
# similar to initCascadeArrays, but without changing content of already existing
# arrays
        if self.cascadeSize is None:
            self.initCascadeArrays(0)

        for j in range(self.cascadeSize,cascadeSize):
            self.addCascadeArrays()
            
#------------------------------------------------------------------------------		
    def addCascadeArrays(self):
#------------------------------------------------------------------------------		

        self.QD_Tt_mod.append(self.createQ_Tt())       
        self.QD_T_mod.append(self.createQ_T())
        self.QA_Tt_mod.append(self.createQ_Tt())      
        self.QA_T_mod.append(self.createQ_T())

        self.USHj_Tt.append(self.createQ_Tt())
        self.USHj_T.append(self.createQ_T())
        self.USHj_t.append(self.createQ_t())
        
        self.QHXj_Tt.append(self.createQ_Tt())
        self.QHXj_T.append(self.createQ_T())
        self.QHXj_t.append(self.createQ_t())

        self.QWHj_Tt.append(self.createQ_Tt())
        self.QWHj_T.append(self.createQ_T())
        self.QWHj_t.append(self.createQ_t())

#..............................................................................
# lists of annual main results

        self.USHj.append(0.0)
        self.QWHj.append(0.0)
        self.QHXj.append(0.0)
        self.FETFuel_j.append(0.0)
        self.FETel_j.append(0.0)
        self.ElGen_j.append(0.0)
        self.FETHeat_j.append(0.0)
        self.HPerYearEq.append(0.0)

        self.cascadeSize += 1

#------------------------------------------------------------------------------		
    def deleteCascadeArrays(self,NEquipe):
#------------------------------------------------------------------------------		

        self.QD_Tt_mod.pop(NEquipe-1)       
        self.QD_T_mod.pop(NEquipe-1)
        self.QA_Tt_mod.pop(NEquipe-1)      
        self.QA_T_mod.pop(NEquipe-1)

        self.USHj_Tt.pop(NEquipe-1)
        self.USHj_T.pop(NEquipe-1)
        self.USHj_t.pop(NEquipe-1)

        self.QHXj_Tt.pop(NEquipe-1)
        self.QHXj_T.pop(NEquipe-1)
        self.QHXj_t.pop(NEquipe-1)

        self.QWHj_Tt.pop(NEquipe-1)
        self.QWHj_T.pop(NEquipe-1)
        self.QWHj_t.pop(NEquipe-1)
#..............................................................................
# lists of annual main results

        self.USHj.pop(NEquipe-1)
        self.QWHj.pop(NEquipe-1)
        self.QHXj.pop(NEquipe-1)
        self.FETFuel_j.pop(NEquipe-1)
        self.FETel_j.pop(NEquipe-1)
        self.ElGen_j.pop(NEquipe-1)
        self.FETHeat_j.pop(NEquipe-1)
        self.HPerYearEq.pop(NEquipe-1)

        self.cascadeSize -= 1
        
#------------------------------------------------------------------------------		
    def printCascade(self,):
#------------------------------------------------------------------------------		

        NT = Status.NT
        print "Heat Demand"
        print "CascadeIndex - QD_total - QD_Tt(first day)"
        for i in range(self.NEquipe+1):
            print i,\
            "%10.4f"%self.QD_T_mod[i][NT+1],\
            self.QD_Tt_mod[i][NT+1][0:23]
        print "Heat Availability"
        print "CascadeIndex - QA_total - QA_Tt(first day)"
        for i in range(self.NEquipe+1):
            print i,\
            "%10.4f"%self.QA_T_mod[i][0],\
            self.QA_Tt_mod[i][0][0:23]
        
#------------------------------------------------------------------------------		
    def printUSH(self):
#------------------------------------------------------------------------------		

        NT = Status.NT
        print "USH"
        print "CascadeIndex - USHj_total - USHj_Tt(first day)"
        for i in range(self.NEquipe+1):
            print i,\
            "%10.4f"%self.USHj_T[i][NT],\
            self.USHj_Tt[i][NT][0:23]
        
#------------------------------------------------------------------------------		
    def printCascade_mod(self,cascade):
#------------------------------------------------------------------------------		

        NT = Status.NT
        print "Heat Demand"
        print "CascadeIndex - QD_total - QD_Tt(first day)"
        for i in range(self.NEquipe+1):
            if i == cascade:
                print i,\
                "%10.4f"%self.QD_T_mod[i][NT+1],\
                self.QD_Tt_mod[i][NT+1][0:23]
            else:
                pass
        print "Heat Availability"
        print "CascadeIndex - QA_total - QA_Tt(first day)"
        for i in range(self.NEquipe+1):
            if i == cascade:
                print i,\
                "%10.4f"%self.QA_T_mod[i][0],\
                self.QA_Tt_mod[i][0][0:23]
            else:
                pass
#------------------------------------------------------------------------------
    def getEquipmentCascade(self):
#------------------------------------------------------------------------------
#   gets the equipment list
#------------------------------------------------------------------------------


        sqlQuery = "Questionnaire_id = '%s' AND AlternativeProposalNo = '%s' ORDER BY CascadeIndex ASC"%(Status.PId,Status.ANo)
        self.equipments = Status.DB.qgenerationhc.sql_select(sqlQuery) #SD change 30/04.2008
        self.NEquipe = len(self.equipments) #SD change 30/04.2008

        self.cascade = []
        for j in range(self.NEquipe):
            self.cascade.append({"equipeID":self.equipments[j].QGenerationHC_ID,\
                                 "equipeNo":self.equipments[j].EqNo,\
                                 "equipeType":self.equipments[j].EquipType,\
                                 "equipePnom":self.equipments[j].HCGPnom})
            if (self.equipments[j].CascadeIndex != j+1):
                print "self (getEquipmentCascade): error in SQL data - cascade index %s corrected to new index %s"%\
                      (self.equipments[j].CascadeIndex,j+1)
                self.equipments[j].CascadeIndex = j+1
                Status.SQL.commit()


        self.EquipTableDataList = []
        for j in range(self.NEquipe):
            self.EquipTableDataList.append([unicode(self.equipments[j].Equipment,"utf-8"),
                                            self.equipments[j].HCGPnom,
                                            self.equipments[j].HCGTEfficiency, \
                                            self.equipments[j].EquipType,
                                            self.equipments[j].HPerYearEq,
                                            self.equipments[j].YearManufact]) #SD change 30/04.2008

        self.extendCascadeArrays(self.NEquipe)  #security feature: assure that for all equipes there's enough space                                       

#------------------------------------------------------------------------------
    def changeInCascade(self,index):
#------------------------------------------------------------------------------
#   gets the equipment list
#------------------------------------------------------------------------------
        if index >= 0:
            self.cascadeUpdateLevel = min(self.cascadeUpdateLevel,index-1)
            Status.prj.setStatus("Energy",0)
            logDebug("Interfaces (changeInCascade): StatusEnergy %s cascadeUpdateLevel: %s "%\
                     (Status.StatusEnergy,self.cascadeUpdateLevel))
        else:
            logDebug("Interfaces (changeInCascade): cannot change a cascade level "+\
                     "that does not exist [-> level %s]"%index)

#------------------------------------------------------------------------------		
    def setGraphicsData(self,key, data):
#------------------------------------------------------------------------------		
# method for storing graphics data
# the data are stored in the dictionary GData under the key 'key'
#------------------------------------------------------------------------------		
        self.GData[key] = copy.deepcopy(data)

#==============================================================================

if __name__ == "__main__":
    # for testing purposes only
    # should be invoked: python interfaces.py
    #
    from einstein.modules.interfaces import Interfaces
    def connectToDB():
        #----- Connect to the Database
        MySql = MySQLdb.connect(host='localhost', user='root', passwd='tom.tom', db='einstein')
        Status.SQL = MySql
        Status.DB =  pSQL.pSQL(MySql, 'einstein')
        print "data base connected ",Status.SQL,Status.DB


    # values for testing purposes
    NT = 5
    Nt = 6
    Status.PId=1
    Status.ANo=1
    # Connect to database
    #
    connectToDB()
    #
    # create an instance of the Interfaces class. This will invoke the __init__ method
    # where the initialization work is done and the class variables are loaded.
    # Afterwards, it is not necessary to instantiate the class, just a reference
    # of type Interfaces.variable will allow access to the class variables.
    intf = Interfaces(NT, Nt) # initialization.
    intf.chargeCurvesQDQA()

    print 'T='+repr(Interfaces.T)
    print 'QDa=' + repr(intf.getQDa())
    print 'QAa=' + repr(intf.getQAa())
    print 'QDh=' + repr(intf.getQDh())
    print 'QAh=' + repr(intf.getQAh())
