#----------------------------------------------------------------------------#
#                                                                            #
# pSQL is (c) 2001 Fionn Behrens <fi@nn.org> and may be distributed and used #
#      freely under the licensing terms of the GNU Public License V2         #
#   (please see www.fsf.org for additional information about this license)   #
#                                                                            #
#   For further information, updates and documentation of pSQL check out :   #
#                      http://software.fionet.com/pSQL/                      #
#                                                                            #
#   If you use this software in a project that is deployed in professional   #
#  environments and/or on a large scale, you should feel obliged to send an  #
# EMail to the author (see top for address), telling him about your project. #
#          Donations are always welcome but, certainly, not required.        #
#                                                                            #
#----------------------------------------------------------------------------#
# Changes made for the Einstein Project
#
# v0.03
#
# Tom Sobota 2008-04-12 Global replacing of None by NULL
#                       changed the default value of Force flag to True so that
#                       updates that don't actually change the value will not
#                       produce errors
#
# The None to NULL change will work with this form of update:
# row = t.select({'id':1})
# row[0].field1 = None
#
# and also with this form:
# row = t.select({'id':1})
# row[0].update({'field1':None})
#
# TS20080418 fix for auto-escaping characters in 'insert' method
#
##############################################################################

from re import sub
from string import split, join, strip, find
from types import StringType, IntType, LongType, DictionaryType
from types import ListType, FloatType, TupleType
try:
  from mx.DateTime import DateTimeType
except:
  from DateTime import DateTimeType

import sys

__version__ = (0,9,8)
__all__     = [ "pSQL" ]
escape      = None   # No escape, hehe ;-)

# pSQL VERSIONS 0.8.9 AND LATER WILL PROBABLY NOT FUNCTION PROPERLY IN 1.5.2
if sys.version[0] < 2:
  print "This version of pSQL requires python version 2.0 or higher. If you"
  print "do not want to upgrade, please use pSQL version 0.8.8."
  sys.exit(1)

#-----------------------------------------------------------------------------

class pSQL(object):
  """This is the main database access class. All other classes below will be
     generated by this one on demand. Create your own instance by calling
     myinst = pSQL.pSQL(connection,database_name) where connection should
     be a DB API 2.0 compliant connection object and database_name a string
     containing the name of the database.
     NOTE: MySQLdb only at the moment. This will change."""

  def __init__(self, connection, name="-unknown-"):
    self._conn = connection
    self._name = name
    try:
      self._c  = connection.cursor()
    except:
      return None
    global escape
    if not escape:
      try:
        escape = connection._db.escape_string
      except:
        try:
          # this is the escape used
          escape = connection.escape_string
        except:
          print "pSQL WARNING: you are not using a supported MySQL module"
          def esc_stub(txt):
            return txt
          escape = esc_stub
    ## This is whacky. I assume that the number or names of tables will not
    ## change while the class instance lives. Besides that it relies on
    ## MySQL/MySQLdb. Subject to compatibility changes.
    self._c.execute("SHOW TABLES")
    self._tables = map(lambda c: "%s" % c, self._c.fetchall())
    self._indices= {}

  #    ------------------------------------------------------------------

  def __getattr__(self, table):
    if table in self._tables:
      return Table(self,table)
    else:
      raise AttributeError, 'No such table in %s: %s' % (self._name, table)

  def __getitem__(self, table):
    return self.__getattr__(table)

  #    ------------------------------------------------------------------

  def __setattr__(self, table, data):
    if table in ["_name","_conn","_c","_tables","_indices"]:
      self.__dict__[table] = data
    elif table in self._tables:
      raise NotImplementedError, '... Sorry!'
      #Table(self,table).write(data)
    else:
      raise AttributeError, 'No such table in %s: %s' % (self._name, table)

  #    ------------------------------------------------------------------

  def create(self, table):
    """------------------------not implemented yet!-----------------------
       Use this method to create a table in this database object. Expected
       argument is a dictionary { name: type , ... } with the column names
       as strings and type being type objects representing the data type
       used in that column"""

    if type(table) != DictionaryType:
      raise TypeError, 'expected dictionary type argument'
    raise NotImplementedError, '... Sorry!'

  #    ------------------------------------------------------------------

  def sql_query(self,query):
    """Use this method to issue raw sql queries into the db. This way
       you dont have to keep an extra cursor. Single values will automatically
       be 'singled out' :-)"""
    self._c.execute(query)
    res = self._c.fetchall()
    while type(res) == TupleType and len(res) == 1: res = res[0]
    return res

  #    ------------------------------------------------------------------

  def keys(self):
    """returns a list of tables in this database """
    return self._tables

  def tables(self): 
    """returns a list of tables in this database """
    return self._tables

  def has_key(self, table):
    """has_key(name) returns true if this database has table 'name'"""
    return table in self._tables

  def __repr__(self):
    return "<pSQL database '%s' at '0x%s'>"%(self._name,hex(id(self))[2:])
  __str__ = __repr__

  def __iter__(self):               # e.g. for table in db: print table
    return self._tables.__iter__()

#-----------------------------------------------------------------------------

class Table(object):
  """Instances of this class represent database tables. Dont use directly.
     This object implements the following methods: insert, select, has_key
     keys, get_table. To retrieve a subset of data from this table use it like:
     table.colname['regex']. Example: addresses.Name["Fionn%"] will give you
     a set of all rows in the 'addresses' table that have 'Name' columns which
     begin with 'Fionn'. Alternatively: addresses['Name']['Fionn%']"""

  def __init__(self, db, name):
    self._name   = name
    self._db     = db
    self._x_refs = {}
    self._used   = 0  # flag if the table has already been used for queries

    ## This is whacky. I dont assume that the number or names of columns
    ## change while the class instance lives.
    self.use_columns()
    self._index = None; self.set_index()

  #    ------------------------------------------------------------------

  def __getattr__(self, col):
    self._used = 1
    return Fetcher(self, col)

  def __getitem__(self, col):
    self._used = 1
    return Fetcher(self, col)

  #    ------------------------------------------------------------------

  def append(self, data):
    """see insert()"""
    self.insert(data)

  def insert(self, data):
    """inserts data into a table. usage: insert(data) where data must be a
       list or a dictionary {field_name:field_value,...}."""
    if type(data) == DictionaryType:
      newrow = self._check_cols_(data)
    elif type(data) == ListType:
      self._check_len_(data)
      newrow = data
    else:
      raise TypeError, 'dictionary or list argument expected'
    """changed to support a more direct insert approach  
    #query = ["INSERT INTO `%s` VALUES (" % self._name]
    #for value in newrow:
    # query.append("'%s'," % _qstr(value))
    #self._db._c.execute("%s%s" % (join(query)[:-1], ")"))"""
    col = ""
    val = ""
    for key in data:
	col += key + ", "
        #TS20080418 change for auto-escaping characters
	#val += "'" + str(data[key]) + "', "
	val += "'" + _qstr(data[key]) + "', "
    query = "INSERT INTO `%s`(%s) VALUES (%s)" % (self._name, col[:-2], val[:-2])
    ####################################################################
    #CANGES 19.02.07 support for NULL
    if query.find("'NULL'") > -1:
	query = query.replace("'NULL'", "NULL")
    #TS20080410 Change None to NULL
    if query.find('None') > -1:
	query = query.replace('None', "NULL")
    ####################################################################    
    self._db._c.execute(query)
    """changes done"""
    
    if self._index: return self._db._c.lastrowid

  #    ------------------------------------------------------------------

  def select(self,data,sort=''):
    """select data from a table. usage: select(query) where query must be a
       dictionary {field_name: sql_regex, ...}.
       Example: table.select({'Name': 'Fi%'}) will return a dictionary of 
       all rows where 'Name' begins with 'Fi'"""
    if not data:
      raise ValueError, 'select needs at least one search term'
    if type(data) == ListType:
      self._check_len_(data)
      newdata = {} ; row = data
      for i in range(1,len(data)):
        if data[i] != "":
          newdata[self._cols[i]] = data[i]
    elif type(data) == DictionaryType:
      self._check_cols_(data)
      newdata = data
    else:
      raise TypeError, 'dictionary or list argument expected'
    self_used = 1
    return Fetcher(self, self._cols[0], sort=sort)[newdata]

  #    ------------------------------------------------------------------

  def sql_select(self,data=""):
    """select data from a table. usage: sql_select(query) where query must be a
       string containing a valid SQL search term!. If no query is provided, the
       entire table will be selected. (DON'T DO THAT IF EVER POSSIBLE)
       Example: table.sql_select("Name = 'Fionn' AND Age > 21") will return a 
       dictionary of all rows where 'Name' is 'Fionn' and 'Age' is greater
       than 21."""
    d = ["SELECT `%s` FROM `%s`" % (join(self._cols, "`,`"), self._name)]
    if data:
      if data[:6] != "SELECT":
        d.append(" WHERE")
      else:
        d = [""]
#    try:
    self._used = 1
    return Fetcher(self, self._cols[0], "%s %s" % (join(d), data))["","SKIP"]
#    except:
#      raise ValueError, 'malformed SQL statement: %s'%(d+data)

  #    ------------------------------------------------------------------

  def set_index(self,name=None):
    """Use this function to define an index field for your table. This 
       function is mainly useful with frequent updating of data or
       complex/problematic table fields, because only the index field
       will be used for identification of the data set instead of all
       fields available. Try to use this function if you keep getting
       exceptions saying 'Result object represents n rows but none have
       been affected by your operation'
       PLEASE CHECK get_index() FIRST, IF AN INDEX IS NOT SET ALREADY!!"""

    if not name:
      if self._index or self._db._indices.has_key(self._name):
        if not self._db._indices[self._name][0] in self._cols:
          del self._db._indices[self._name]
          return self.set_index()
        if not self._index: self._index = self._db._indices[self._name]
        return self._index[0]
      else:
        idx = list(self._db.sql_query("SHOW INDEX FROM `%s`" % self._name))
        if not idx: return None
        if idx[0] != self._name: # if there is more than one index then
          for i in idx[:]:
            if not i[4] in self._cols:
              idx.remove(i)
          if not idx: return None # Some wise guy excluded all index columns
          for i in idx:           # get first unique index if possible
            if not i[1]:          # i[1] == 0 means unique
              idx = [i]           # (of course this is completely MySQL'ish)
              break
          idx = idx[0]            # But any index will do "for the moment"
        self.set_index(idx[4])
        return self._index[0]
    elif name in self._cols:
      self._db._indices[self._name] = [name,self._cols.index(name)]
      self._index = [name,self._cols.index(name)]
    else:
      raise KeyError, 'No such column in %s: %s' % (self._name,name)

  def get_index(self):
    """Returns the name of any index field that is being used to identify
       records during UPDATE clauses. 
       (and for cross references, see x_ref() for more information)"""
    return self.set_index()

  #    ------------------------------------------------------------------

  def get_table(self):
    """Warning! This reads the whole table! Use only for small tables."""
    return self.sql_select()

  #    ------------------------------------------------------------------

  def x_ref(self, other, id_here, id_there=None, name=None, multi=1):
    """Use this method to generate 'virtual' cross references between SQL
       tables - even if they are in totally different databases. Needed:
       an index field in the target table, a field in this table that holds
       pointers to that index field and a name for your reference.
       usage: x_ref( target_table, field_here, index_field_there, name, multi )
       example: see docs for examples. """
    if not id_here in self._cols:
      raise KeyError, 'No such column in %s: %s' % (self._name,id_here)
    if not id_there:
      idx = other.get_index()
      if idx:
        id_there = idx
      else:
        raise LookupError, 'no foreign id specified and no index found'
    if not id_there in other._cols:
      raise KeyError, 'No such column in %s: %s' % (other._name,id_there)
    if not name:
      name = other._name
    self._x_refs[name] = [id_here, id_there, other, multi]

  #    ------------------------------------------------------------------

  def keys(self):
    """use this method to retrieve the names of all columns and all cross
       references in this table"""
    return self._cols + self._x_refs.keys()

  def has_key(self, key):
    """use this method to determine whether this table has a certain column
       or cross reference"""
    return key in self.keys()

  def columns(self):
    """use this method to retrieve the names of all columns in this table"""
    return self._cols

  def use_columns(self, cols=[], force = 0):
    """use this method to set the names of all columns you want to use in this
       table. That way you can define a subset of columns for your queries.
       If no argument or an empty list is provided, the complete list of
       columns will be retrieved from the database."""
    if not type(cols) == ListType:
      raise TypeError, 'list argument expected'
    # MySQL only - again:
    self._db._c.execute("SHOW COLUMNS FROM `%s`" % self._name)
    my_columns  = self._db._c.fetchall()
    newcols     = map(lambda c: "%s"%c[0], my_columns)
    if self._used and not force:
      raise TypeError, 'Columns can only be changed on an unused table object! Use force=1 to override this.'
    self._cols  = map(lambda c: "%s"%c[0], my_columns)
    self._types = map(lambda c: "%s"%split(c[1],"(")[0], my_columns)
    if cols:
      for c in cols:
        if c not in self._cols:
          raise KeyError, 'No such column in %s: %s' % (self._name, c)
      for c in self._cols[:]:
        if c not in cols:
          cidx = self._cols.index(c)
          del self._cols[cidx]
          del self._types[cidx]
      self._index = None
      if not self.get_index():
        if not force:
          self.use_columns()
          err = 'You are trying to exclude all index columns (%s) from ' % c +\
                'your queries. This is a bad idea[tm]. Use "force=1" ' +\
                'to override.'
          raise IndexError, err

  def ignore_column(self, col): 
    """use this method to exclude a column in a table from being used by pSQL"""
    if col not in self._cols:
      raise KeyError, 'No such column in %s: %s' % (self._name, c)
    cx = self._cols[:]; cx.remove(col) 
    self.use_columns(cx)

  def has_column(self, col): 
    """use this method to determine whether this table has a certain column"""
    return col in self._cols

  #    ------------------------------------------------------------------

  def __repr__(self):
    return "<pSQL table '%s' of database '%s' at '0x%s'>"%(self._name,\
                                              self._db._name,hex(id(self))[2:])
  __str__ = __repr__

  def __len__(self):
    return int(self._db._c.execute("SELECT COUNT(*) FROM `%s`" % self._name))

  def __nonzero__(self):
    return (len(self) > 0)

  def __cmp__(self,other):
    try: return (self._name != other._name or self._db != other._db)
    except: return -1

  def __eq__(self, other):
    return not(self.__cmp__(other))

  def __coerce__(self,other):
    return [None,(self,other)][hasattr(other,"_x_refs")]

  def __iter__(self):
    return self._cols.__iter__()

  #    ------------------------------------------------------------------

  def _check_cols_(self, data):
    newrow = []
    keys = data.keys()
    for col in self._cols:
      if col in keys:
        newrow.append(data[col])
        keys.remove(col)
      else:
        newrow.append("")
    if len(keys):
      err = 'No such column in %s: %s' % (self._name, keys[0])
      raise KeyError, err
    return newrow

  #    ------------------------------------------------------------------

  def _check_len_(self,data):
    if len(data) != len(self._cols):
      raise ValueError, 'argument mismatch. Expected %s values, got %s' % \
                                                (len(self._cols), len(data))

  #    ------------------------------------------------------------------

  def _sql_compile(self,queries,old=""):
    qustr = old
    pre = "SELECT `%s` FROM `%s` WHERE" % (join(self._cols,"`,`"), self._name)
    for q in queries.keys():
      qu = queries[q]
      if type(qu) == TupleType:
        if len(qu) == 1: qu = qu + ("AND",)
      else:
        qu = (queries[q], "AND")

      if qu[1] != "SKIP":
        s = _qstr(qu[0])
        if len(qu) == 2: qu += (["=", "LIKE"][s.find("%") != -1],)
        qustr="%s %s `%s` %s '%s'" % (qustr, [pre,qu[1]][qustr!=""], q, qu[2],s)

    return qustr

  #    ------------------------------------------------------------------

#-----------------------------------------------------------------------------

class Fetcher(object):
  """This is a helper object used to retrieve and hold results from the SQL
     database. Normally this object should be transparent to you. Do not
     use directly!"""

  def __init__(self, table, col, queries="", column=[], sort=''):
    if not col in table._cols:
      raise KeyError, 'No such column in %s: %s' % (table._name, strip(str(col)))
    self._table   = table
    self._col     = col
    self._queries = queries
    self._mode    = "fetch"
    self._results = column
    self._sort    = sort
    self._count   = 0        # how deep to dig in the result set

  #    ------------------------------------------------------------------

  def __getitem__(self,query):
    if self._mode == "fetch":
      return self._fetch(query)
    elif type(query) == IntType:
      return self._results[query]
    elif type(query) == StringType:
      return self.__getattr__(query) 
    else:
      raise TypeError, 'expected integer index or column name string'

  #    ------------------------------------------------------------------

  def _fetch(self,query):
    self._queries = self._table._sql_compile([{self._col:query},query][type(query)==DictionaryType],self._queries)
    self._results = []
    if self._table._db._c.execute(self._queries+['',' ORDER BY %s' % self._sort][self._sort!='']):
      sqlresults    = self._table._db._c.fetchall()
      if self._table._index:
        # If there is an index we assume there are no identical records.
        for result in sqlresults:
          self._results.append(Result(self,list(result)))
      else:  
        for result in sqlresults:
          ## We are checking for IDENTICAL results. For data consistency
          ## issues they will be delivered only as one object.
          resobj = Result(self,list(result))
          if self._results and resobj in self._results:
            i = self._results.index(resobj)
            self._results[i]._rows = self._results[i]._rows + 1
          else:
            self._results.append(resobj)
    self._mode = "hold"
    return self

  #    ------------------------------------------------------------------

  def __setitem__(self,item,data):
    if not type(item) == IntType or type(item) == LongType:
      raise TypeError, 'array index must be a number'
    if isinstance(data, Result) and data._fetch._table == self._table:
      self._results[item] = data
    else:
      raise TypeError, 'argument must be a pSQL result object from table %s of %s'%(self._table._name,self._table._db._name)

  def __delitem__(self,item):
    del self._results[item]

  #    ------------------------------------------------------------------

  def __getattr__(self, col):
    if self._mode == "hold":
      if not col in self._table._cols:
        raise KeyError, 'No such column in %s: %s' % (self._table._name,col)
      return Fetcher(self._table, col, self._queries, self.column(col))

  #    ------------------------------------------------------------------

  def __iter__(self):
    if self._mode == "hold":
      return self._results.__iter__()
    else:
      raise TypeError, 'iteration over non-sequence'

  #    ------------------------------------------------------------------

  def __getslice__(self,a,b):
    if self._mode == "hold":
      f = Fetcher(self._table, self._col, self._queries)
      f._mode = "hold"
      f._results = self._results[a:b]
      return f
    else:
      self._fetch("%")
      self._results = self._results[a:b]
      return self

  #    ------------------------------------------------------------------

  def __contains__(self, res):
    return res in self._results

  def __nonzero__(self):
    return self._results != []

  def __repr__(self):
    if self._mode == "fetch":
      return "<pSQL data fetcher object at '0x%s'>"%hex(id(self))[2:]
    else:
      return repr(self._results)
  __str__ = __repr__

  def __len__(self):
    if self._mode == "fetch":
      try:                               # This is MySQL only!!
        cinf = self._table._db.sql_query("SHOW COLUMNS FROM `%s` LIKE '%s'"%\
                                            (self._table._name, self._col))[1]
        return int(cinf[find(cinf,"(")+1:find(cinf,")")])
      except:
        return int(len(self._table))
    else:
      return len(self._results)

  #    ------------------------------------------------------------------

  def __cmp__(self,other):
    try:
      if self._mode == "hold" and other._mode == "hold":
        return self._results != other._results
      else:
        return (self._queries != other._queries or\
                self._table != other._table or self._col != other._col)
    except: return -1

  def __eq__(self, other):
    return not(self.__cmp__(other))

  def __add__(self,data):
    if self._mode == "hold":
      res = self[0:]
      res.append(data)
      return res
    else:
      raise TypeError, 'bad operand type(s) for +'

  def __coerce__(self,other):
    return [None, (self, other)][self._mode == "hold" and\
                                 hasattr(other,"_mode") and\
                                 other._mode == "hold"]

  #    ------------------------------------------------------------------

  def append(self, data):
    """Use this method to append results to your result set. Note that
       any appended data will be lost as soon as you apply new queries to
       the set."""
    if self._mode == "hold":
      if isinstance(data, Result) and data._fetch._table == self._table:
        if not data in self._results:
          self._results.append(data)
          data._fetch = self
      elif hasattr(data,"_col") and data._mode == "hold":
        for res in data: self.append(res)
      else:
        raise TypeError, 'argument must be a pSQL result object from table %s of %s'%(self._table._name,self._table._db._name)
    else:
      raise AttributeError, 'append'

  #    ------------------------------------------------------------------

  def index(self, item=None):
    if self._mode == "hold":
      return self._results.index(item)
    else:
      return self.__getitem__('index')

  #    ------------------------------------------------------------------

  def pop(self):
    """Use this method to pop items from THE TOP of your result set. Note that
       any popped data will be restored as soon as you apply new queries to
       the set."""
    if self._mode == "hold":
      if len(self) > 0:
        pdata = self._results[0]
        del self._results[0]
        return pdata
      else:
        raise IndexError, 'pop from empty list'
    else:
      raise AttributeError, 'pop'

  #    ------------------------------------------------------------------

  def column(self, col=None):
    """Usage: Call this function like result_set.column('mycol'). This will
       give you all columns named 'mycol' from the result set in one list.
       Example: a = mydb.Adresses.Name['Behrens'] will give you all adresses
       where 'Name' is 'Behrens'. Now you can get all phone numbers in one list
       by issuing nums = a.column('Phone') (OR: num = a.Phone.column() OR
       num = a["Phone"].column() but the last two are more expensive unless
       you intend to re-use a.Phone for further queries)."""
    if self._mode == "hold":
      c = col or self._col
      if len(self):
        virtual = self[0]._virtual.keys()
      else:
        virtual = []
      if not c in self._table._cols + self._table._x_refs.keys() + virtual:
        raise KeyError, 'No such column, virtual or xref : %s' % c
      res = []
      if self and isinstance(self[0][c], Result): # if column contains res
        res = self[0:0]                             # object use result set
        res._table = self[0][c]._fetch._table       # object for storage
        res._col = self[0][c]._fetch._col
      for r in self._results:
        try:
          res.append(r[c])
        except:
          res.append(None)
      return res
    elif not self._results:
      raise LookupError, 'No result set yet. Use %s.%s["%%"].column() ?'% \
                                            (self._table._name, self._col)
    else:
      return self._results

  #    ------------------------------------------------------------------

  def get_next(self):
    pass

  def get_prev(self):
    pass

  #    ------------------------------------------------------------------

  def sort(self, col=None, col2=None):
    """Use this function to sort a result set by a specific column.
       example: a = mydb.Adresses.Name['Fionn%']; a.sort('Birthday')
       This will sort your result set by the values of the 'Birthday'
       column. Hint: If you need this often, it might be faster to
       let the database engine 'sort it out', e.g. by using
       a = mydb.Adresses.sql_select("Name LIKE 'Fionn%' ORDER BY Birthday")
       You can even sort by fields of cross referenced data:
       e.g. >>> a.sort('Account', 'Number') if 'Account' would be a cross
       reference."""
    if not len(self._results):
      return
    if not col:
      if not self._table._index:
        raise ValueError, 'sort needs a column argument or an index'
      else: scol = self._table._index
    else:
      if type(col) == StringType: scol = col
      elif type(col) == IntType:
        if col <= len(self._table._cols):
          scol = self._table._cols[col]
        else:
          raise ValueError, 'sort index out of bounds (only %i columns)'%len(self._table._cols)
    slist = self.column(scol)
    if isinstance(slist[0], Result) and col2:   # if column itself is result set
      slist.sort(col2)                          # we can sort by a field of that
    else:
      slist.sort()                              # else use regular sort
    res = []
    for item in slist:
      for i in range(len(self._results)):
        if self._results[i][scol] == item:
          res.append(self._results[i])
          del self._results[i]
          break;
    self._results = res

  def reverse(self):
    self._results.reverse()

#-----------------------------------------------------------------------------

class Result(object):
  """Objects of this class are used to hold single results (rows) of a
     database. If a table holds more than one completely identical rows,
     these objects may represent all of them at once, however. They can 
     be used like a dictionary (keys and values) OR like a list (values only). 
     Changing a value will change the respective value in the database as well. 

     Example: Given I hold the following row from an address database: 
     repr(row) == {'Name': 'Fionn Behrens', 'Street': 'Gluckaufstrasse', ...}
     you can retrieve data like row.Name OR row['Name'] OR row[1] - all will
     result in 'Fionn Behrens'. 
     Delete a row with row.delete() - will be deleted from the database, too."""

  def __init__(self, fetcher, data):
    self._fetch    = fetcher
    self._data     = data
    self._rows     = 1
    self._cols     = fetcher._table._cols
    self._xr_cache = {}
    self._virtual  = {}

  #    ------------------------------------------------------------------

  def __getitem__(self, arg):
    if type(arg) == StringType:
      if arg in self._cols:
        return self._data[self._cols.index(arg)]
      elif arg in self._fetch._table._x_refs.keys():
        return self._get_xref(arg)
      elif arg in self._virtual.keys():
        return self._virtual[arg]
      else:
        raise KeyError,'No such field in %s: %s'%(self._fetch._table._name,arg)
    elif type(arg) == IntType:
      return self._data[arg]
    else:
      raise TypeError, 'string or integer argument expected'

  def __getslice__(self, a, b):
    if type(a) == type(b) == IntType:
      return self._data[a:b]
    else:
      raise TypeError, 'sequence index must be integer'

  #    ------------------------------------------------------------------

  def __setitem__(self, arg, data):
    if type(arg) == StringType:
      if arg in self._cols:
        i = self._cols.index(arg)
      elif arg in self._virtual.keys():
        self._virtual[arg] = data
      elif arg in self._fetch._table._x_refs.keys():
        raise ValueError, "cross references can not be replaced."
      else:
        raise KeyError,'No such field in %s: %s'%(self._fetch._table._name,arg)
    elif type(arg) == IntType:
      if abs(arg) > len(self._data):
        raise IndexError, 'data index out of range'
      i = arg
    else:
      raise TypeError, 'string or integer argument expected'

    query = "UPDATE `%s` SET `%s`='%s' %s" % (self._fetch._table._name,
                                              self._cols[i],
                                              _qstr(data), self._qlist())
            #self._cols[i]+"='"+_qstr(data)+"'"+self._qlist()
    ####################################################################
    #TS 20080412 This replace is done in _do_query
    #CANGES 19.02.07 support for NULL
    #if query.find("'NULL'") > -1:
    #	query = query.replace("'NULL'", "NULL")
    ####################################################################
    #TS 20080412 disabled this test.
    #noex = (self._data[i] == data or type(data) == FloatType \
    #                              or _qstr(self._data[i]) == str(data) )
    #self._do_query(query, noex)
    self._do_query(query, True)
    self._data[i] = data

  #    ------------------------------------------------------------------

  def __getattr__(self, arg):
    return self.__getitem__(arg)

  def __setattr__(self, arg, data):
    if arg in ["_fetch","_data","_rows","_cols","_xr_cache","_virtual"]:
      self.__dict__[arg] = data
    else:
      self.__setitem__(arg, data)

  #    ------------------------------------------------------------------

  def setVirtual(self, name, data):
    """This method may be used to attach random data to a result for further
       use. E.g. related data sets to be used in several stages of some
       complex computation. Access data like normal columns. Virtual fields
       are not being displayed by repr()"""
    if name in self._cols:
        raise ValueError, "Virtual columns can not replace regular columns."
    elif name in self._fetch._table._x_refs.keys():
        raise ValueError, "Virtual columns can not use names of cross ref's."
    self._virtual[name] = data

  def delVirtual(self, name):
    del self._virtual[name]

  def remove(self):
    self.delete()

  #    ------------------------------------------------------------------

  def update(self, data, force=True):
    """This method may be used to update all or certain columns of a certain
       result (row). Expected argument is a dictionary or a complete list.
       Optional argument is 'force' True or False, (default False). Use
       force = True to suppress exceptions in case of an update that does
       not actually change anything in the database.

       TS20080412 WARNING changed the force default to be True
       """
    if type(data) == DictionaryType:
      self._fetch._table._check_cols_(data)
      qdata = data
    elif type(data) == ListType:
      self._fetch._table._check_len_(data)
      qdata = {}
      #TS 20080412 deleted this test. it is done in _do_query
      #for l in range(len(self._cols)):
        #if data[l] != None: qdata[self._cols[l]] = data[l]
        #  qdata[self._cols[l]] = data[l]
      qdata[self._cols[l]] = data[l]
    else:
      raise TypeError, 'dictionary or list argument expected'
    query = ["UPDATE `%s` SET" % self._fetch._table._name]
    for col in qdata:
      query.append("`%s`='%s'," % (col, _qstr(qdata[col])))
    self._do_query("%s%s" % (join(query)[:-1], self._qlist()), force)      

    
    for col in self._cols:
      if col in qdata:
        self._data[self._cols.index(col)] = qdata[col]

  #    ------------------------------------------------------------------

  def delete(self, recursion=None):
    """Usage: row.delete([recursion]). The Optional recursion argument
       triggers recursive deletion of cross referenced data. So if you
       have a table with names and a table with adresses and a table with
       phone numbers and have your names x-referenced with adresses and
       the latter x-referenced with phone a name.delete(2) will delete
       the referenced address and phone number from their tables as well.
       name.delete(1) will only delete the name and adress, not the phone.
       USE RECURSION WITH CARE! DELETED DATA CAN NOT BE RECOVERED!"""

    self._do_query("DELETE FROM `%s`%s"%(self._fetch._table._name,self._qlist()))
    if self in self._fetch._results:
      self._fetch._results.remove(self)
    if recursion and self._fetch._table._x_refs.keys():
      xr = self._fetch._table._x_refs
      for item in xr.keys():
        testitem = self._get_xref(item)
        xrefs = len(self._fetch._table[xr[item][0]][testitem[xr[item][1]]])
        if not xrefs:
          if isinstance(testitem, Result):
            testitem.delete(recursion-1)
          elif isinstance(testitem, Fetcher):
            while len(testitem):
              testitem[0].delete(recursion-1)
    del self

  #    ------------------------------------------------------------------

  def __repr__(self):
    rep = ["{"]
    for l in range(len(self._cols)):
      rep.append("'%s': %s, "%(self._cols[l],repr(self._data[l])))
    return "%s%s" % (join(rep)[:-2], "}")
  __str__ = __repr__

  def __len__(self):
    return len(self._data)

  def __nonzero__(self):
    return self._data != []

  def __iter__(self):
    return self._cols.__iter__()

  #    ------------------------------------------------------------------

  def __cmp__(self,other):
    return not(isinstance(other, Result) and other._data == self._data)

  def __lt__(self, other):
    raise TypeError, 'pSQL result objects can not be compared this way'
  def __le__(self, other):
    raise TypeError, 'pSQL result objects can not be compared this way'
  def __eq__(self, other):
    return not(self.__cmp__(other))
  def __ne__(self, other):
    return self.__cmp__(other)
  def __gt__(self, other):
    raise TypeError, 'pSQL result objects can not be compared this way'
  def __ge__(self, other):
    raise TypeError, 'pSQL result objects can not be compared this way'

  #    ------------------------------------------------------------------

  def keys(self):
    return self._cols + self._fetch._table._x_refs.keys() + self._virtual.keys()

  def has_key(self, name): return name in self.keys()

  def columns(self): return self._fetch._table.columns()

  def has_column(self, col): return self._fetch._table.has_column(col)

  def values(self):
    data = self._data
    for key in self._fetch._table._x_refs.keys(): data.append(self[key])
    data.append(self._virtual.values())
    return data

  def row(self): return self._data

  #    ------------------------------------------------------------------

  def _qlist(self):
    # This method assembles the SQL query string matching component. If you
    # are updating your data frequently, it is recommended to use table
    # indices (see table.set_index()).
    query = [" WHERE "]
    idx = self._fetch._table._index
    if idx:
      query.append("`%s`='%s'" % (idx[0], _qstr(self._data[idx[1]])))
      return join(query)
    else:
      for i in range(len(self._data)):
        query.append("`%s`='%s' AND " % (self._cols[i], _qstr(self._data[i])))
      return join(query)[:-5]

  def _do_query(self, query, ex_mode=True):
    # This method does the actual queries. If more or less rows than desired
    # are affected, it will raise an exception.
    # ex_mode is introduced for queries that actually change a value to itself.
    # For such queries it might not be desireable to raise an exception because
    # they are perfectly legal.
    #20080412 changed the ex_mode default to True
    try:
      ####################################################################
      #CANGES 19.02.07 support for NULL
      if query.find("'NULL'") > -1:
          query = query.replace("'NULL'", "NULL")
      #TS 20080412 change None to NULL
      if query.find("None") > -1:
          query = query.replace("None", "NULL")
      ####################################################################    
 
      num = self._fetch._table._db._c.execute(query)
    except:
      raise IOError, 'An error occured while trying to execute: %s' % query
    if not (num or ex_mode):
      raise IOError, "Result object represents %i row%s, but none has been affected by:\n\t %s" % (self._rows, ["","s"][self._rows>1], query)
    elif num and num != self._rows:
      raise IOError, "Result object represents %i row%s, but %s have been affected by your operation:\n\t%s" % (self._rows, ["","s"][self._rows>1], str(int(num)), query)

  def _get_xref(self, arg):
    if not arg in self._xr_cache.keys():
      xref = self._fetch._table._x_refs[arg]
      try:
        xr = xref[2][xref[1]][self[xref[0]]]
      except:
        xr = []
      if xref[3] > 1:
        self._xr_cache[arg] = xr
      else:
        if len(xr) != 1:
          if len(xr) > 1:
            # 1:n reference: FUBAR. Use MULTI!! We'll delete that one.
            del self._fetch._table._x_refs[arg]
            raise LookupError, '1:n cross reference without multi=2: "%s" (%i).'%(arg,len(xr))
          elif not xref[3]:
            self._xr_cache[arg] = None
          else:
            raise LookupError, 'Dangling cross reference: "%s".' % arg
        else:
          self._xr_cache[arg] = xr[0]
    return self._xr_cache[arg]

#-----------------------------------------------------------------------------

def _qstr(t):
  try:
    if type(t) == StringType: s = escape(t)
    elif type(t) == DateTimeType: s = t.strftime("%Y-%m-%d %H:%M:%S")
    else: s = escape(str(t))
  except:
    s = ''
  return s

#-----------------------------------------------------------------------------
